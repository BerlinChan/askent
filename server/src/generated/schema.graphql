### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Event {
  code: String!
  createdAt: DateTime!
  endAt: DateTime
  id: UUID!
  name: String!
  owner: User!
  questions(after: String, before: String, first: Int, last: Int, skip: Int): [Question!]!
  startAt: DateTime
  updatedAt: DateTime!
}

input EventCreateInput {
  code: String!
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String!
  owner: UserCreateOneWithoutOwnerInput!
  questions: QuestionCreateManyWithoutQuestionsInput
  startAt: DateTime
  updatedAt: DateTime
}

input EventCreateManyWithoutEventsInput {
  connect: [EventWhereUniqueInput!]
  create: [EventCreateWithoutOwnerInput!]
}

input EventCreateOneWithoutEventInput {
  connect: EventWhereUniqueInput
  create: EventCreateWithoutQuestionsInput
}

input EventCreateWithoutOwnerInput {
  code: String!
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String!
  questions: QuestionCreateManyWithoutQuestionsInput
  startAt: DateTime
  updatedAt: DateTime
}

input EventCreateWithoutQuestionsInput {
  code: String!
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String!
  owner: UserCreateOneWithoutOwnerInput!
  startAt: DateTime
  updatedAt: DateTime
}

input EventFilter {
  every: EventWhereInput
  none: EventWhereInput
  some: EventWhereInput
}

input EventScalarWhereInput {
  AND: [EventScalarWhereInput!]
  code: StringFilter
  createdAt: DateTimeFilter
  endAt: NullableDateTimeFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  questions: QuestionFilter
  startAt: NullableDateTimeFilter
  updatedAt: DateTimeFilter
}

input EventUpdateInput {
  code: String
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String
  owner: UserUpdateOneRequiredWithoutEventsInput
  questions: QuestionUpdateManyWithoutEventInput
  startAt: DateTime
  updatedAt: DateTime
}

input EventUpdateManyDataInput {
  code: String
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String
  startAt: DateTime
  updatedAt: DateTime
}

input EventUpdateManyMutationInput {
  code: String
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String
  startAt: DateTime
  updatedAt: DateTime
}

input EventUpdateManyWithoutOwnerInput {
  connect: [EventWhereUniqueInput!]
  create: [EventCreateWithoutOwnerInput!]
  delete: [EventWhereUniqueInput!]
  deleteMany: [EventScalarWhereInput!]
  disconnect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutOwnerInput!]
}

input EventUpdateManyWithWhereNestedInput {
  data: EventUpdateManyDataInput!
  where: EventScalarWhereInput!
}

input EventUpdateOneRequiredWithoutQuestionsInput {
  connect: EventWhereUniqueInput
  create: EventCreateWithoutQuestionsInput
  update: EventUpdateWithoutQuestionsDataInput
  upsert: EventUpsertWithoutQuestionsInput
}

input EventUpdateWithoutOwnerDataInput {
  code: String
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String
  questions: QuestionUpdateManyWithoutEventInput
  startAt: DateTime
  updatedAt: DateTime
}

input EventUpdateWithoutQuestionsDataInput {
  code: String
  createdAt: DateTime
  endAt: DateTime
  id: UUID
  name: String
  owner: UserUpdateOneRequiredWithoutEventsInput
  startAt: DateTime
  updatedAt: DateTime
}

input EventUpdateWithWhereUniqueWithoutOwnerInput {
  data: EventUpdateWithoutOwnerDataInput!
  where: EventWhereUniqueInput!
}

input EventUpsertWithoutQuestionsInput {
  create: EventCreateWithoutQuestionsInput!
  update: EventUpdateWithoutQuestionsDataInput!
}

input EventUpsertWithWhereUniqueWithoutOwnerInput {
  create: EventCreateWithoutOwnerInput!
  update: EventUpdateWithoutOwnerDataInput!
  where: EventWhereUniqueInput!
}

input EventWhereInput {
  AND: [EventWhereInput!]
  code: StringFilter
  createdAt: DateTimeFilter
  endAt: NullableDateTimeFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  owner: UserWhereInput
  questions: QuestionFilter
  startAt: NullableDateTimeFilter
  updatedAt: DateTimeFilter
}

input EventWhereUniqueInput {
  code: String
  id: UUID
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  createOneEvent(data: EventCreateInput!): Event!
  createOneQuestion(data: QuestionCreateInput!): Question!
  createOneUser(data: UserCreateInput!): User!
  deleteManyEvent(where: EventWhereInput): BatchPayload!
  deleteManyQuestion(where: QuestionWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneEvent(where: EventWhereUniqueInput!): Event
  deleteOneQuestion(where: QuestionWhereUniqueInput!): Question
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyEvent(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  updateManyQuestion(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateOneQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneEvent(create: EventCreateInput!, update: EventUpdateInput!, where: EventWhereUniqueInput!): Event!
  upsertOneQuestion(create: QuestionCreateInput!, update: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  event(where: EventWhereUniqueInput!): Event
  events(after: UUID, before: UUID, first: Int, last: Int, skip: Int): [Event!]!
  question(where: QuestionWhereUniqueInput!): Question
  questions(after: String, before: String, first: Int, last: Int, skip: Int): [Question!]!
  user(where: UserWhereUniqueInput!): User
  users(after: ID, before: ID, first: Int, last: Int, skip: Int): [User!]!
}

type Question {
  content: String!
  createdAt: DateTime!
  event: Event!
  id: String!
  updatedAt: DateTime!
  user: User
  username: String
  vote: Int!
}

input QuestionCreateInput {
  content: String!
  createdAt: DateTime
  event: EventCreateOneWithoutEventInput!
  id: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput
  username: String
  vote: Int
}

input QuestionCreateManyWithoutQuestionsInput {
  connect: [QuestionWhereUniqueInput!]
  create: [QuestionCreateWithoutEventInput!]
}

input QuestionCreateWithoutEventInput {
  content: String!
  createdAt: DateTime
  id: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput
  username: String
  vote: Int
}

input QuestionCreateWithoutUserInput {
  content: String!
  createdAt: DateTime
  event: EventCreateOneWithoutEventInput!
  id: String!
  updatedAt: DateTime
  username: String
  vote: Int
}

input QuestionFilter {
  every: QuestionWhereInput
  none: QuestionWhereInput
  some: QuestionWhereInput
}

input QuestionScalarWhereInput {
  AND: [QuestionScalarWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  updatedAt: DateTimeFilter
  username: NullableStringFilter
  vote: IntFilter
}

input QuestionUpdateInput {
  content: String
  createdAt: DateTime
  event: EventUpdateOneRequiredWithoutQuestionsInput
  id: String
  updatedAt: DateTime
  user: UserUpdateOneWithoutQuestionsInput
  username: String
  vote: Int
}

input QuestionUpdateManyDataInput {
  content: String
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  username: String
  vote: Int
}

input QuestionUpdateManyMutationInput {
  content: String
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  username: String
  vote: Int
}

input QuestionUpdateManyWithoutEventInput {
  connect: [QuestionWhereUniqueInput!]
  create: [QuestionCreateWithoutEventInput!]
  delete: [QuestionWhereUniqueInput!]
  deleteMany: [QuestionScalarWhereInput!]
  disconnect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutEventInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutEventInput!]
}

input QuestionUpdateManyWithoutUserInput {
  connect: [QuestionWhereUniqueInput!]
  create: [QuestionCreateWithoutUserInput!]
  delete: [QuestionWhereUniqueInput!]
  deleteMany: [QuestionScalarWhereInput!]
  disconnect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutUserInput!]
}

input QuestionUpdateManyWithWhereNestedInput {
  data: QuestionUpdateManyDataInput!
  where: QuestionScalarWhereInput!
}

input QuestionUpdateWithoutEventDataInput {
  content: String
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  user: UserUpdateOneWithoutQuestionsInput
  username: String
  vote: Int
}

input QuestionUpdateWithoutUserDataInput {
  content: String
  createdAt: DateTime
  event: EventUpdateOneRequiredWithoutQuestionsInput
  id: String
  updatedAt: DateTime
  username: String
  vote: Int
}

input QuestionUpdateWithWhereUniqueWithoutEventInput {
  data: QuestionUpdateWithoutEventDataInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpdateWithWhereUniqueWithoutUserInput {
  data: QuestionUpdateWithoutUserDataInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpsertWithWhereUniqueWithoutEventInput {
  create: QuestionCreateWithoutEventInput!
  update: QuestionUpdateWithoutEventDataInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpsertWithWhereUniqueWithoutUserInput {
  create: QuestionCreateWithoutUserInput!
  update: QuestionUpdateWithoutUserDataInput!
  where: QuestionWhereUniqueInput!
}

input QuestionWhereInput {
  AND: [QuestionWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  event: EventWhereInput
  id: StringFilter
  NOT: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  username: NullableStringFilter
  vote: IntFilter
}

input QuestionWhereUniqueInput {
  id: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  createdAt: DateTime!
  email: String!
  events(after: UUID, before: UUID, first: Int, last: Int, skip: Int): [Event!]!
  id: ID!
  lastLoginAt: DateTime
  name: String
  questions(after: String, before: String, first: Int, last: Int, skip: Int): [Question!]!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  events: EventCreateManyWithoutEventsInput
  id: ID
  lastLoginAt: DateTime
  name: String
  questions: QuestionCreateManyWithoutQuestionsInput
  updatedAt: DateTime
}

input UserCreateOneWithoutOwnerInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutEventsInput
}

input UserCreateOneWithoutUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuestionsInput
}

input UserCreateWithoutEventsInput {
  createdAt: DateTime
  email: String!
  id: ID
  lastLoginAt: DateTime
  name: String
  questions: QuestionCreateManyWithoutQuestionsInput
  updatedAt: DateTime
}

input UserCreateWithoutQuestionsInput {
  createdAt: DateTime
  email: String!
  events: EventCreateManyWithoutEventsInput
  id: ID
  lastLoginAt: DateTime
  name: String
  updatedAt: DateTime
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  events: EventUpdateManyWithoutOwnerInput
  id: ID
  lastLoginAt: DateTime
  name: String
  questions: QuestionUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateManyMutationInput {
  createdAt: DateTime
  email: String
  id: ID
  lastLoginAt: DateTime
  name: String
  updatedAt: DateTime
}

input UserUpdateOneRequiredWithoutEventsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutEventsInput
  update: UserUpdateWithoutEventsDataInput
  upsert: UserUpsertWithoutEventsInput
}

input UserUpdateOneWithoutQuestionsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutQuestionsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutQuestionsDataInput
  upsert: UserUpsertWithoutQuestionsInput
}

input UserUpdateWithoutEventsDataInput {
  createdAt: DateTime
  email: String
  id: ID
  lastLoginAt: DateTime
  name: String
  questions: QuestionUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateWithoutQuestionsDataInput {
  createdAt: DateTime
  email: String
  events: EventUpdateManyWithoutOwnerInput
  id: ID
  lastLoginAt: DateTime
  name: String
  updatedAt: DateTime
}

input UserUpsertWithoutEventsInput {
  create: UserCreateWithoutEventsInput!
  update: UserUpdateWithoutEventsDataInput!
}

input UserUpsertWithoutQuestionsInput {
  create: UserCreateWithoutQuestionsInput!
  update: UserUpdateWithoutQuestionsDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  events: EventFilter
  id: StringFilter
  lastLoginAt: NullableDateTimeFilter
  name: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  questions: QuestionFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: ID
  name: String
}

scalar UUID

input UUIDFilter {
  contains: UUID
  endsWith: UUID
  equals: UUID
  gt: UUID
  gte: UUID
  in: [UUID!]
  lt: UUID
  lte: UUID
  not: UUID
  notIn: [UUID!]
  startsWith: UUID
}
