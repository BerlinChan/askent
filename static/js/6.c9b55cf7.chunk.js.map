{"version":3,"sources":["generated/graphqlHooks.tsx"],"names":["EventDateStatus","EventOwnerFilter","ReviewStatus","RoleName","defaultOptions","QuestionFieldsFragmentDoc","gql","ReplyFieldsFragmentDoc","EventFieldsFragmentDoc","EventDetailFieldsFragmentDoc","QuestionAudienceFieldsFragmentDoc","UserInfoFragmentDoc","GuestesByEventDocument","useGuestesByEventQuery","baseOptions","options","Apollo","AddGuestDocument","useAddGuestMutation","RemoveGuestDocument","useRemoveGuestMutation","DeleteQuestionDocument","useDeleteQuestionMutation","DeleteAllReviewQuestionsDocument","useDeleteAllReviewQuestionsMutation","PublishAllReviewQuestionsDocument","usePublishAllReviewQuestionsMutation","UpdateQuestionReviewStatusDocument","useUpdateQuestionReviewStatusMutation","UpdateQuestionStarDocument","useUpdateQuestionStarMutation","UpdateQuestionTopDocument","useUpdateQuestionTopMutation","UpdateQuestionContentDocument","useUpdateQuestionContentMutation","CreateReplyDocument","useCreateReplyMutation","UpdateReplyContentDocument","useUpdateReplyContentMutation","UpdateReplyReviewStatusDocument","useUpdateReplyReviewStatusMutation","DeleteReplyDocument","useDeleteReplyMutation","EventsByMeDocument","useEventsByMeQuery","EventByIdDocument","useEventByIdLazyQuery","CheckEventCodeExistDocument","useCheckEventCodeExistQuery","useCheckEventCodeExistLazyQuery","CreateEventDocument","useCreateEventMutation","UpdateEventDocument","useUpdateEventMutation","DeleteEventDocument","useDeleteEventMutation","PackageInfoDocument","usePackageInfoMutation","EventForLoginDocument","useEventForLoginQuery","CreateQuestionDocument","useCreateQuestionMutation","VoteUpQuestionDocument","useVoteUpQuestionMutation","LoginAudienceDocument","useLoginAudienceMutation","IsEventAudienceDocument","useIsEventAudienceLazyQuery","JoinEventDocument","useJoinEventMutation","EventCodeOptionsDocument","useEventCodeOptionsLazyQuery","MeDocument","useMeQuery","useMeLazyQuery","UpdateUserDocument","useUpdateUserMutation","LoginDocument","useLoginMutation","SignupDocument","useSignupMutation","CheckEmailExistDocument","useCheckEmailExistLazyQuery"],"mappings":"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","file":"static/js/6.c9b55cf7.chunk.js","sourcesContent":["import { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nexport type Maybe<T> = T | null;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nconst defaultOptions =  {}\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** The javascript `Date` as string. Type represents date and time as the ISO Date string. */\n  DateTime: any;\n};\n\nexport type AuthPayload = {\n  __typename?: 'AuthPayload';\n  token: Scalars['String'];\n  user: User;\n};\n\nexport type CreateQuestionInput = {\n  eventId: Scalars['ID'];\n  content: Scalars['String'];\n  anonymous?: Maybe<Scalars['Boolean']>;\n};\n\nexport type CreateReplyInput = {\n  questionId: Scalars['ID'];\n  content: Scalars['String'];\n  anonymous: Scalars['Boolean'];\n};\n\n\nexport type Event = {\n  __typename?: 'Event';\n  id: Scalars['ID'];\n  code: Scalars['String'];\n  name: Scalars['String'];\n  startAt: Scalars['DateTime'];\n  endAt: Scalars['DateTime'];\n  moderation: Scalars['Boolean'];\n  dateStatus: EventDateStatus;\n  owner: User;\n  guestes: Array<User>;\n  audiences: Array<User>;\n  questions: Array<Question>;\n  createdAt: Scalars['DateTime'];\n  updatedAt: Scalars['DateTime'];\n};\n\nexport enum EventDateStatus {\n  Active = 'Active',\n  Upcoming = 'Upcoming',\n  Past = 'Past'\n}\n\nexport enum EventOwnerFilter {\n  Owner = 'Owner',\n  Guest = 'Guest'\n}\n\nexport type EventPaged = IPagedType & {\n  __typename?: 'EventPaged';\n  offset: Scalars['Int'];\n  limit: Scalars['Int'];\n  totalCount: Scalars['Int'];\n  hasNextPage: Scalars['Boolean'];\n  list: Array<Event>;\n};\n\nexport type IPagedType = {\n  offset: Scalars['Int'];\n  limit: Scalars['Int'];\n  totalCount: Scalars['Int'];\n  hasNextPage: Scalars['Boolean'];\n};\n\nexport type Mutation = {\n  __typename?: 'Mutation';\n  /** Add a user as guest administrator, who can cooperating manage the event. */\n  addGuest: User;\n  createEvent: Event;\n  /** Create question */\n  createQuestion: Question;\n  createReply: Reply;\n  createRole: Role;\n  /** Delete all Review questions by event. */\n  deleteAllReviewQuestions: Scalars['Int'];\n  deleteEvent: Event;\n  /** Delete a question by id. */\n  deleteQuestion: Question;\n  /** Delete a reply by id. */\n  deleteReply: Reply;\n  /** 加入活动。 */\n  joinEvent: Scalars['ID'];\n  login: AuthPayload;\n  /**\n   * Audience 登陆。\n   *   若 fingerprint 的 User 已存在则返回 token，\n   *   若 fingerprint 的 User 不存在则 create 并返回 token\n   */\n  loginAudience: AuthPayload;\n  packageInfo: PackageInfo;\n  /** Publish all Review questions by event. */\n  publishAllReviewQuestions: Scalars['Int'];\n  removeGuest: Scalars['ID'];\n  seedEvent: Scalars['Int'];\n  seedQuestion: Scalars['Int'];\n  seedReply: Scalars['Int'];\n  seedRole: Scalars['Int'];\n  /** Signup a new user. */\n  signup: AuthPayload;\n  updateEvent: Event;\n  /** Update a question content. */\n  updateQuestionContent: Question;\n  /** Update a question review status. */\n  updateQuestionReviewStatus: Question;\n  /** Update a question star. */\n  updateQuestionStar: Question;\n  /** Top a question. Can only top one question at a time. */\n  updateQuestionTop: Question;\n  /** Update a reply's content. */\n  updateReplyContent: Reply;\n  /** Update a reply's review status. */\n  updateReplyReviewStatus: Reply;\n  updateUser: User;\n  /** Vote a question. */\n  voteUpQuestion: Question;\n};\n\n\nexport type MutationAddGuestArgs = {\n  email: Scalars['String'];\n  eventId: Scalars['ID'];\n};\n\n\nexport type MutationCreateEventArgs = {\n  code: Scalars['String'];\n  name: Scalars['String'];\n  startAt: Scalars['DateTime'];\n  endAt: Scalars['DateTime'];\n};\n\n\nexport type MutationCreateQuestionArgs = {\n  input: CreateQuestionInput;\n};\n\n\nexport type MutationCreateReplyArgs = {\n  input: CreateReplyInput;\n};\n\n\nexport type MutationCreateRoleArgs = {\n  name: RoleName;\n};\n\n\nexport type MutationDeleteAllReviewQuestionsArgs = {\n  eventId: Scalars['ID'];\n};\n\n\nexport type MutationDeleteEventArgs = {\n  eventId: Scalars['ID'];\n};\n\n\nexport type MutationDeleteQuestionArgs = {\n  questionId: Scalars['ID'];\n};\n\n\nexport type MutationDeleteReplyArgs = {\n  replyId: Scalars['ID'];\n};\n\n\nexport type MutationJoinEventArgs = {\n  eventId: Scalars['ID'];\n};\n\n\nexport type MutationLoginArgs = {\n  email: Scalars['String'];\n  password: Scalars['String'];\n};\n\n\nexport type MutationLoginAudienceArgs = {\n  fingerprint: Scalars['String'];\n};\n\n\nexport type MutationPackageInfoArgs = {\n  version?: Maybe<Scalars['String']>;\n  description?: Maybe<Scalars['String']>;\n};\n\n\nexport type MutationPublishAllReviewQuestionsArgs = {\n  eventId: Scalars['ID'];\n};\n\n\nexport type MutationRemoveGuestArgs = {\n  guestId: Scalars['ID'];\n  eventId: Scalars['ID'];\n};\n\n\nexport type MutationSeedQuestionArgs = {\n  eventId: Scalars['String'];\n};\n\n\nexport type MutationSeedReplyArgs = {\n  anonymous?: Maybe<Scalars['Boolean']>;\n  questionId: Scalars['String'];\n};\n\n\nexport type MutationSignupArgs = {\n  name: Scalars['String'];\n  email: Scalars['String'];\n  password: Scalars['String'];\n};\n\n\nexport type MutationUpdateEventArgs = {\n  input: UpdateEventInput;\n};\n\n\nexport type MutationUpdateQuestionContentArgs = {\n  questionId: Scalars['ID'];\n  content: Scalars['String'];\n};\n\n\nexport type MutationUpdateQuestionReviewStatusArgs = {\n  reviewStatus: ReviewStatus;\n  questionId: Scalars['ID'];\n};\n\n\nexport type MutationUpdateQuestionStarArgs = {\n  star: Scalars['Boolean'];\n  questionId: Scalars['ID'];\n};\n\n\nexport type MutationUpdateQuestionTopArgs = {\n  top: Scalars['Boolean'];\n  questionId: Scalars['ID'];\n};\n\n\nexport type MutationUpdateReplyContentArgs = {\n  content: Scalars['String'];\n  replyId: Scalars['ID'];\n};\n\n\nexport type MutationUpdateReplyReviewStatusArgs = {\n  reviewStatus: ReviewStatus;\n  replyId: Scalars['ID'];\n};\n\n\nexport type MutationUpdateUserArgs = {\n  input: UpdateUserInput;\n};\n\n\nexport type MutationVoteUpQuestionArgs = {\n  questionId: Scalars['ID'];\n};\n\nexport type Pgp = {\n  __typename?: 'PGP';\n  pubKey: Scalars['String'];\n};\n\nexport type PackageInfo = {\n  __typename?: 'PackageInfo';\n  version: Scalars['String'];\n  description: Scalars['String'];\n};\n\nexport type PaginationInput = {\n  /** Default offset 0. */\n  offset?: Maybe<Scalars['Int']>;\n  /** Default limit 50 */\n  limit?: Maybe<Scalars['Int']>;\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  /** Check if a email has already exist. */\n  checkEmailExist: Scalars['Boolean'];\n  /** Check if a event code has already exist. */\n  checkEventCodeExist: Scalars['Boolean'];\n  eventById: Event;\n  /** Get events by code. */\n  eventsByCode: Array<Event>;\n  /** Get all my events. */\n  eventsByMe: EventPaged;\n  isEventAudience: Scalars['Boolean'];\n  me: User;\n  packageInfo: PackageInfo;\n  /** For demo use */\n  pgp: Pgp;\n  roles: Array<Role>;\n};\n\n\nexport type QueryCheckEmailExistArgs = {\n  email: Scalars['String'];\n};\n\n\nexport type QueryCheckEventCodeExistArgs = {\n  code: Scalars['String'];\n};\n\n\nexport type QueryEventByIdArgs = {\n  eventId: Scalars['ID'];\n};\n\n\nexport type QueryEventsByCodeArgs = {\n  code?: Maybe<Scalars['String']>;\n};\n\n\nexport type QueryEventsByMeArgs = {\n  dateStatusFilter?: Maybe<EventDateStatus>;\n  eventOwnerFilter?: Maybe<EventOwnerFilter>;\n  searchString?: Maybe<Scalars['String']>;\n  pagination: PaginationInput;\n};\n\n\nexport type QueryIsEventAudienceArgs = {\n  eventId: Scalars['ID'];\n};\n\nexport type Question = {\n  __typename?: 'Question';\n  id: Scalars['ID'];\n  content: Scalars['String'];\n  anonymous: Scalars['Boolean'];\n  reviewStatus: ReviewStatus;\n  star: Scalars['Boolean'];\n  top: Scalars['Boolean'];\n  voteUpCount: Scalars['Int'];\n  replyCount: Scalars['Int'];\n  event: Event;\n  author?: Maybe<User>;\n  voted: Scalars['Boolean'];\n  createdAt: Scalars['DateTime'];\n  updatedAt: Scalars['DateTime'];\n};\n\nexport type Reply = {\n  __typename?: 'Reply';\n  id: Scalars['ID'];\n  content: Scalars['String'];\n  reviewStatus: ReviewStatus;\n  /** If author is a moderator of the event? */\n  isModerator: Scalars['Boolean'];\n  anonymous: Scalars['Boolean'];\n  question: Question;\n  author?: Maybe<User>;\n  createdAt: Scalars['DateTime'];\n  updatedAt: Scalars['DateTime'];\n};\n\n/** Question's or Reply's review status */\nexport enum ReviewStatus {\n  Review = 'Review',\n  Publish = 'Publish',\n  Archive = 'Archive'\n}\n\nexport type Role = {\n  __typename?: 'Role';\n  id: Scalars['ID'];\n  name: Scalars['String'];\n};\n\nexport enum RoleName {\n  User = 'User',\n  Audience = 'Audience'\n}\n\nexport type UpdateEventInput = {\n  eventId: Scalars['ID'];\n  code?: Maybe<Scalars['String']>;\n  name?: Maybe<Scalars['String']>;\n  startAt?: Maybe<Scalars['DateTime']>;\n  endAt?: Maybe<Scalars['DateTime']>;\n  moderation?: Maybe<Scalars['Boolean']>;\n};\n\nexport type UpdateUserInput = {\n  name?: Maybe<Scalars['String']>;\n  email?: Maybe<Scalars['String']>;\n  anonymous?: Maybe<Scalars['Boolean']>;\n};\n\nexport type User = {\n  __typename?: 'User';\n  id: Scalars['ID'];\n  email?: Maybe<Scalars['String']>;\n  name?: Maybe<Scalars['String']>;\n  anonymous?: Maybe<Scalars['Boolean']>;\n  avatar?: Maybe<Scalars['String']>;\n  roles: Array<Role>;\n  createdAt: Scalars['DateTime'];\n  updatedAt: Scalars['DateTime'];\n  deletedAt?: Maybe<Scalars['DateTime']>;\n};\n\nexport type GuestesByEventQueryVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type GuestesByEventQuery = (\n  { __typename?: 'Query' }\n  & { eventById: (\n    { __typename?: 'Event' }\n    & Pick<Event, 'id'>\n    & { guestes: Array<(\n      { __typename?: 'User' }\n      & Pick<User, 'id' | 'name' | 'email'>\n    )> }\n  ) }\n);\n\nexport type AddGuestMutationVariables = Exact<{\n  email: Scalars['String'];\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type AddGuestMutation = (\n  { __typename?: 'Mutation' }\n  & { addGuest: (\n    { __typename?: 'User' }\n    & Pick<User, 'id' | 'name' | 'email'>\n  ) }\n);\n\nexport type RemoveGuestMutationVariables = Exact<{\n  eventId: Scalars['ID'];\n  guestId: Scalars['ID'];\n}>;\n\n\nexport type RemoveGuestMutation = (\n  { __typename?: 'Mutation' }\n  & Pick<Mutation, 'removeGuest'>\n);\n\nexport type QuestionFieldsFragment = (\n  { __typename?: 'Question' }\n  & Pick<Question, 'id' | 'createdAt' | 'updatedAt' | 'voteUpCount' | 'replyCount' | 'content' | 'reviewStatus' | 'star' | 'top'>\n  & { author?: Maybe<(\n    { __typename?: 'User' }\n    & Pick<User, 'id' | 'name' | 'avatar'>\n  )> }\n);\n\nexport type DeleteQuestionMutationVariables = Exact<{\n  questionId: Scalars['ID'];\n}>;\n\n\nexport type DeleteQuestionMutation = (\n  { __typename?: 'Mutation' }\n  & { deleteQuestion: (\n    { __typename?: 'Question' }\n    & Pick<Question, 'id'>\n  ) }\n);\n\nexport type DeleteAllReviewQuestionsMutationVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type DeleteAllReviewQuestionsMutation = (\n  { __typename?: 'Mutation' }\n  & Pick<Mutation, 'deleteAllReviewQuestions'>\n);\n\nexport type PublishAllReviewQuestionsMutationVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type PublishAllReviewQuestionsMutation = (\n  { __typename?: 'Mutation' }\n  & Pick<Mutation, 'publishAllReviewQuestions'>\n);\n\nexport type UpdateQuestionReviewStatusMutationVariables = Exact<{\n  questionId: Scalars['ID'];\n  reviewStatus: ReviewStatus;\n}>;\n\n\nexport type UpdateQuestionReviewStatusMutation = (\n  { __typename?: 'Mutation' }\n  & { updateQuestionReviewStatus: (\n    { __typename?: 'Question' }\n    & QuestionFieldsFragment\n  ) }\n);\n\nexport type UpdateQuestionStarMutationVariables = Exact<{\n  questionId: Scalars['ID'];\n  star: Scalars['Boolean'];\n}>;\n\n\nexport type UpdateQuestionStarMutation = (\n  { __typename?: 'Mutation' }\n  & { updateQuestionStar: (\n    { __typename?: 'Question' }\n    & QuestionFieldsFragment\n  ) }\n);\n\nexport type UpdateQuestionTopMutationVariables = Exact<{\n  questionId: Scalars['ID'];\n  top: Scalars['Boolean'];\n}>;\n\n\nexport type UpdateQuestionTopMutation = (\n  { __typename?: 'Mutation' }\n  & { updateQuestionTop: (\n    { __typename?: 'Question' }\n    & QuestionFieldsFragment\n  ) }\n);\n\nexport type UpdateQuestionContentMutationVariables = Exact<{\n  questionId: Scalars['ID'];\n  content: Scalars['String'];\n}>;\n\n\nexport type UpdateQuestionContentMutation = (\n  { __typename?: 'Mutation' }\n  & { updateQuestionContent: (\n    { __typename?: 'Question' }\n    & QuestionFieldsFragment\n  ) }\n);\n\nexport type ReplyFieldsFragment = (\n  { __typename?: 'Reply' }\n  & Pick<Reply, 'id' | 'createdAt' | 'updatedAt' | 'content' | 'reviewStatus' | 'isModerator'>\n  & { author?: Maybe<(\n    { __typename?: 'User' }\n    & Pick<User, 'id' | 'name' | 'avatar'>\n  )> }\n);\n\nexport type CreateReplyMutationVariables = Exact<{\n  input: CreateReplyInput;\n}>;\n\n\nexport type CreateReplyMutation = (\n  { __typename?: 'Mutation' }\n  & { createReply: (\n    { __typename?: 'Reply' }\n    & ReplyFieldsFragment\n  ) }\n);\n\nexport type UpdateReplyContentMutationVariables = Exact<{\n  replyId: Scalars['ID'];\n  content: Scalars['String'];\n}>;\n\n\nexport type UpdateReplyContentMutation = (\n  { __typename?: 'Mutation' }\n  & { updateReplyContent: (\n    { __typename?: 'Reply' }\n    & ReplyFieldsFragment\n  ) }\n);\n\nexport type UpdateReplyReviewStatusMutationVariables = Exact<{\n  replyId: Scalars['ID'];\n  reviewStatus: ReviewStatus;\n}>;\n\n\nexport type UpdateReplyReviewStatusMutation = (\n  { __typename?: 'Mutation' }\n  & { updateReplyReviewStatus: (\n    { __typename?: 'Reply' }\n    & ReplyFieldsFragment\n  ) }\n);\n\nexport type DeleteReplyMutationVariables = Exact<{\n  replyId: Scalars['ID'];\n}>;\n\n\nexport type DeleteReplyMutation = (\n  { __typename?: 'Mutation' }\n  & { deleteReply: (\n    { __typename?: 'Reply' }\n    & Pick<Reply, 'id'>\n  ) }\n);\n\nexport type EventFieldsFragment = (\n  { __typename?: 'Event' }\n  & Pick<Event, 'id' | 'name' | 'code' | 'startAt' | 'endAt' | 'dateStatus'>\n);\n\nexport type EventDetailFieldsFragment = (\n  { __typename?: 'Event' }\n  & Pick<Event, 'id' | 'name' | 'code' | 'startAt' | 'endAt' | 'dateStatus' | 'moderation'>\n  & { owner: (\n    { __typename?: 'User' }\n    & Pick<User, 'id' | 'name' | 'email'>\n  ) }\n);\n\nexport type EventsByMeQueryVariables = Exact<{\n  searchString?: Maybe<Scalars['String']>;\n  pagination: PaginationInput;\n  eventOwnerFilter?: Maybe<EventOwnerFilter>;\n  dateStatusFilter?: Maybe<EventDateStatus>;\n}>;\n\n\nexport type EventsByMeQuery = (\n  { __typename?: 'Query' }\n  & { eventsByMe: (\n    { __typename?: 'EventPaged' }\n    & Pick<EventPaged, 'limit' | 'offset' | 'totalCount' | 'hasNextPage'>\n    & { list: Array<(\n      { __typename?: 'Event' }\n      & EventFieldsFragment\n    )> }\n  ) }\n);\n\nexport type EventByIdQueryVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type EventByIdQuery = (\n  { __typename?: 'Query' }\n  & { eventById: (\n    { __typename?: 'Event' }\n    & EventDetailFieldsFragment\n  ) }\n);\n\nexport type CheckEventCodeExistQueryVariables = Exact<{\n  code: Scalars['String'];\n}>;\n\n\nexport type CheckEventCodeExistQuery = (\n  { __typename?: 'Query' }\n  & Pick<Query, 'checkEventCodeExist'>\n);\n\nexport type CreateEventMutationVariables = Exact<{\n  code: Scalars['String'];\n  name: Scalars['String'];\n  startAt: Scalars['DateTime'];\n  endAt: Scalars['DateTime'];\n}>;\n\n\nexport type CreateEventMutation = (\n  { __typename?: 'Mutation' }\n  & { createEvent: (\n    { __typename?: 'Event' }\n    & EventFieldsFragment\n  ) }\n);\n\nexport type UpdateEventMutationVariables = Exact<{\n  input: UpdateEventInput;\n}>;\n\n\nexport type UpdateEventMutation = (\n  { __typename?: 'Mutation' }\n  & { updateEvent: (\n    { __typename?: 'Event' }\n    & EventDetailFieldsFragment\n  ) }\n);\n\nexport type DeleteEventMutationVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type DeleteEventMutation = (\n  { __typename?: 'Mutation' }\n  & { deleteEvent: (\n    { __typename?: 'Event' }\n    & Pick<Event, 'id'>\n  ) }\n);\n\nexport type PgpQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type PgpQuery = (\n  { __typename?: 'Query' }\n  & { pgp: (\n    { __typename?: 'PGP' }\n    & Pick<Pgp, 'pubKey'>\n  ) }\n);\n\nexport type PackageInfoMutationVariables = Exact<{\n  version?: Maybe<Scalars['String']>;\n  description?: Maybe<Scalars['String']>;\n}>;\n\n\nexport type PackageInfoMutation = (\n  { __typename?: 'Mutation' }\n  & { packageInfo: (\n    { __typename?: 'PackageInfo' }\n    & Pick<PackageInfo, 'version' | 'description'>\n  ) }\n);\n\nexport type EventForLoginQueryVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type EventForLoginQuery = (\n  { __typename?: 'Query' }\n  & { eventById: (\n    { __typename?: 'Event' }\n    & Pick<Event, 'id' | 'name' | 'code' | 'startAt' | 'endAt'>\n  ) }\n);\n\nexport type QuestionAudienceFieldsFragment = (\n  { __typename?: 'Question' }\n  & Pick<Question, 'id' | 'anonymous' | 'createdAt' | 'updatedAt' | 'content' | 'reviewStatus' | 'top' | 'star' | 'voted' | 'voteUpCount' | 'replyCount'>\n  & { author?: Maybe<(\n    { __typename?: 'User' }\n    & Pick<User, 'id' | 'name' | 'avatar'>\n  )> }\n);\n\nexport type CreateQuestionMutationVariables = Exact<{\n  input: CreateQuestionInput;\n}>;\n\n\nexport type CreateQuestionMutation = (\n  { __typename?: 'Mutation' }\n  & { createQuestion: (\n    { __typename?: 'Question' }\n    & QuestionAudienceFieldsFragment\n  ) }\n);\n\nexport type VoteUpQuestionMutationVariables = Exact<{\n  questionId: Scalars['ID'];\n}>;\n\n\nexport type VoteUpQuestionMutation = (\n  { __typename?: 'Mutation' }\n  & { voteUpQuestion: (\n    { __typename?: 'Question' }\n    & QuestionAudienceFieldsFragment\n  ) }\n);\n\nexport type LoginAudienceMutationVariables = Exact<{\n  fingerprint: Scalars['String'];\n}>;\n\n\nexport type LoginAudienceMutation = (\n  { __typename?: 'Mutation' }\n  & { loginAudience: (\n    { __typename?: 'AuthPayload' }\n    & Pick<AuthPayload, 'token'>\n    & { user: (\n      { __typename?: 'User' }\n      & Pick<User, 'name'>\n    ) }\n  ) }\n);\n\nexport type IsEventAudienceQueryVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type IsEventAudienceQuery = (\n  { __typename?: 'Query' }\n  & Pick<Query, 'isEventAudience'>\n);\n\nexport type JoinEventMutationVariables = Exact<{\n  eventId: Scalars['ID'];\n}>;\n\n\nexport type JoinEventMutation = (\n  { __typename?: 'Mutation' }\n  & Pick<Mutation, 'joinEvent'>\n);\n\nexport type QuestionWallFieldsFragment = (\n  { __typename?: 'Question' }\n  & Pick<Question, 'id' | 'createdAt' | 'updatedAt' | 'content' | 'reviewStatus' | 'top' | 'star' | 'voteUpCount' | 'replyCount'>\n  & { author?: Maybe<(\n    { __typename?: 'User' }\n    & Pick<User, 'id' | 'name' | 'avatar'>\n  )> }\n);\n\nexport type EventCodeOptionsQueryVariables = Exact<{\n  code?: Maybe<Scalars['String']>;\n}>;\n\n\nexport type EventCodeOptionsQuery = (\n  { __typename?: 'Query' }\n  & { eventsByCode: Array<(\n    { __typename?: 'Event' }\n    & Pick<Event, 'id' | 'code' | 'name' | 'startAt' | 'endAt'>\n  )> }\n);\n\nexport type UserInfoFragment = (\n  { __typename?: 'User' }\n  & Pick<User, 'id' | 'name' | 'anonymous' | 'email' | 'avatar'>\n  & { roles: Array<(\n    { __typename?: 'Role' }\n    & Pick<Role, 'id' | 'name'>\n  )> }\n);\n\nexport type MeQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type MeQuery = (\n  { __typename?: 'Query' }\n  & { me: (\n    { __typename?: 'User' }\n    & UserInfoFragment\n  ) }\n);\n\nexport type UpdateUserMutationVariables = Exact<{\n  input: UpdateUserInput;\n}>;\n\n\nexport type UpdateUserMutation = (\n  { __typename?: 'Mutation' }\n  & { updateUser: (\n    { __typename?: 'User' }\n    & UserInfoFragment\n  ) }\n);\n\nexport type LoginMutationVariables = Exact<{\n  email: Scalars['String'];\n  password: Scalars['String'];\n}>;\n\n\nexport type LoginMutation = (\n  { __typename?: 'Mutation' }\n  & { login: (\n    { __typename?: 'AuthPayload' }\n    & Pick<AuthPayload, 'token'>\n    & { user: (\n      { __typename?: 'User' }\n      & Pick<User, 'name' | 'email'>\n    ) }\n  ) }\n);\n\nexport type SignupMutationVariables = Exact<{\n  name: Scalars['String'];\n  email: Scalars['String'];\n  password: Scalars['String'];\n}>;\n\n\nexport type SignupMutation = (\n  { __typename?: 'Mutation' }\n  & { signup: (\n    { __typename?: 'AuthPayload' }\n    & Pick<AuthPayload, 'token'>\n    & { user: (\n      { __typename?: 'User' }\n      & Pick<User, 'name' | 'email'>\n    ) }\n  ) }\n);\n\nexport type CheckEmailExistQueryVariables = Exact<{\n  email: Scalars['String'];\n}>;\n\n\nexport type CheckEmailExistQuery = (\n  { __typename?: 'Query' }\n  & Pick<Query, 'checkEmailExist'>\n);\n\nexport const QuestionFieldsFragmentDoc = gql`\n    fragment QuestionFields on Question {\n  id\n  createdAt\n  updatedAt\n  voteUpCount\n  replyCount\n  content\n  reviewStatus\n  star\n  top\n  author {\n    id\n    name\n    avatar\n  }\n}\n    `;\nexport const ReplyFieldsFragmentDoc = gql`\n    fragment ReplyFields on Reply {\n  id\n  createdAt\n  updatedAt\n  content\n  reviewStatus\n  isModerator\n  author {\n    id\n    name\n    avatar\n  }\n}\n    `;\nexport const EventFieldsFragmentDoc = gql`\n    fragment EventFields on Event {\n  id\n  name\n  code\n  startAt\n  endAt\n  dateStatus\n}\n    `;\nexport const EventDetailFieldsFragmentDoc = gql`\n    fragment EventDetailFields on Event {\n  id\n  name\n  code\n  startAt\n  endAt\n  dateStatus\n  moderation\n  owner {\n    id\n    name\n    email\n  }\n}\n    `;\nexport const QuestionAudienceFieldsFragmentDoc = gql`\n    fragment QuestionAudienceFields on Question {\n  id\n  anonymous\n  createdAt\n  updatedAt\n  content\n  reviewStatus\n  top\n  star\n  voted\n  voteUpCount\n  replyCount\n  author {\n    id\n    name\n    avatar\n  }\n}\n    `;\nexport const QuestionWallFieldsFragmentDoc = gql`\n    fragment QuestionWallFields on Question {\n  id\n  createdAt\n  updatedAt\n  content\n  reviewStatus\n  top\n  star\n  voteUpCount\n  replyCount\n  author {\n    id\n    name\n    avatar\n  }\n}\n    `;\nexport const UserInfoFragmentDoc = gql`\n    fragment UserInfo on User {\n  id\n  name\n  anonymous\n  email\n  avatar\n  roles {\n    id\n    name\n  }\n}\n    `;\nexport const GuestesByEventDocument = gql`\n    query GuestesByEvent($eventId: ID!) {\n  eventById(eventId: $eventId) {\n    id\n    guestes {\n      id\n      name\n      email\n    }\n  }\n}\n    `;\n\n/**\n * __useGuestesByEventQuery__\n *\n * To run a query within a React component, call `useGuestesByEventQuery` and pass it any options that fit your needs.\n * When your component renders, `useGuestesByEventQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useGuestesByEventQuery({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useGuestesByEventQuery(baseOptions: Apollo.QueryHookOptions<GuestesByEventQuery, GuestesByEventQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<GuestesByEventQuery, GuestesByEventQueryVariables>(GuestesByEventDocument, options);\n      }\nexport function useGuestesByEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GuestesByEventQuery, GuestesByEventQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<GuestesByEventQuery, GuestesByEventQueryVariables>(GuestesByEventDocument, options);\n        }\nexport type GuestesByEventQueryHookResult = ReturnType<typeof useGuestesByEventQuery>;\nexport type GuestesByEventLazyQueryHookResult = ReturnType<typeof useGuestesByEventLazyQuery>;\nexport type GuestesByEventQueryResult = Apollo.QueryResult<GuestesByEventQuery, GuestesByEventQueryVariables>;\nexport const AddGuestDocument = gql`\n    mutation AddGuest($email: String!, $eventId: ID!) {\n  addGuest(email: $email, eventId: $eventId) {\n    id\n    name\n    email\n  }\n}\n    `;\nexport type AddGuestMutationFn = Apollo.MutationFunction<AddGuestMutation, AddGuestMutationVariables>;\n\n/**\n * __useAddGuestMutation__\n *\n * To run a mutation, you first call `useAddGuestMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useAddGuestMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [addGuestMutation, { data, loading, error }] = useAddGuestMutation({\n *   variables: {\n *      email: // value for 'email'\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useAddGuestMutation(baseOptions?: Apollo.MutationHookOptions<AddGuestMutation, AddGuestMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<AddGuestMutation, AddGuestMutationVariables>(AddGuestDocument, options);\n      }\nexport type AddGuestMutationHookResult = ReturnType<typeof useAddGuestMutation>;\nexport type AddGuestMutationResult = Apollo.MutationResult<AddGuestMutation>;\nexport type AddGuestMutationOptions = Apollo.BaseMutationOptions<AddGuestMutation, AddGuestMutationVariables>;\nexport const RemoveGuestDocument = gql`\n    mutation RemoveGuest($eventId: ID!, $guestId: ID!) {\n  removeGuest(eventId: $eventId, guestId: $guestId)\n}\n    `;\nexport type RemoveGuestMutationFn = Apollo.MutationFunction<RemoveGuestMutation, RemoveGuestMutationVariables>;\n\n/**\n * __useRemoveGuestMutation__\n *\n * To run a mutation, you first call `useRemoveGuestMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useRemoveGuestMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [removeGuestMutation, { data, loading, error }] = useRemoveGuestMutation({\n *   variables: {\n *      eventId: // value for 'eventId'\n *      guestId: // value for 'guestId'\n *   },\n * });\n */\nexport function useRemoveGuestMutation(baseOptions?: Apollo.MutationHookOptions<RemoveGuestMutation, RemoveGuestMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<RemoveGuestMutation, RemoveGuestMutationVariables>(RemoveGuestDocument, options);\n      }\nexport type RemoveGuestMutationHookResult = ReturnType<typeof useRemoveGuestMutation>;\nexport type RemoveGuestMutationResult = Apollo.MutationResult<RemoveGuestMutation>;\nexport type RemoveGuestMutationOptions = Apollo.BaseMutationOptions<RemoveGuestMutation, RemoveGuestMutationVariables>;\nexport const DeleteQuestionDocument = gql`\n    mutation DeleteQuestion($questionId: ID!) {\n  deleteQuestion(questionId: $questionId) {\n    id\n  }\n}\n    `;\nexport type DeleteQuestionMutationFn = Apollo.MutationFunction<DeleteQuestionMutation, DeleteQuestionMutationVariables>;\n\n/**\n * __useDeleteQuestionMutation__\n *\n * To run a mutation, you first call `useDeleteQuestionMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteQuestionMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteQuestionMutation, { data, loading, error }] = useDeleteQuestionMutation({\n *   variables: {\n *      questionId: // value for 'questionId'\n *   },\n * });\n */\nexport function useDeleteQuestionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteQuestionMutation, DeleteQuestionMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<DeleteQuestionMutation, DeleteQuestionMutationVariables>(DeleteQuestionDocument, options);\n      }\nexport type DeleteQuestionMutationHookResult = ReturnType<typeof useDeleteQuestionMutation>;\nexport type DeleteQuestionMutationResult = Apollo.MutationResult<DeleteQuestionMutation>;\nexport type DeleteQuestionMutationOptions = Apollo.BaseMutationOptions<DeleteQuestionMutation, DeleteQuestionMutationVariables>;\nexport const DeleteAllReviewQuestionsDocument = gql`\n    mutation DeleteAllReviewQuestions($eventId: ID!) {\n  deleteAllReviewQuestions(eventId: $eventId)\n}\n    `;\nexport type DeleteAllReviewQuestionsMutationFn = Apollo.MutationFunction<DeleteAllReviewQuestionsMutation, DeleteAllReviewQuestionsMutationVariables>;\n\n/**\n * __useDeleteAllReviewQuestionsMutation__\n *\n * To run a mutation, you first call `useDeleteAllReviewQuestionsMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteAllReviewQuestionsMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteAllReviewQuestionsMutation, { data, loading, error }] = useDeleteAllReviewQuestionsMutation({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useDeleteAllReviewQuestionsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAllReviewQuestionsMutation, DeleteAllReviewQuestionsMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<DeleteAllReviewQuestionsMutation, DeleteAllReviewQuestionsMutationVariables>(DeleteAllReviewQuestionsDocument, options);\n      }\nexport type DeleteAllReviewQuestionsMutationHookResult = ReturnType<typeof useDeleteAllReviewQuestionsMutation>;\nexport type DeleteAllReviewQuestionsMutationResult = Apollo.MutationResult<DeleteAllReviewQuestionsMutation>;\nexport type DeleteAllReviewQuestionsMutationOptions = Apollo.BaseMutationOptions<DeleteAllReviewQuestionsMutation, DeleteAllReviewQuestionsMutationVariables>;\nexport const PublishAllReviewQuestionsDocument = gql`\n    mutation PublishAllReviewQuestions($eventId: ID!) {\n  publishAllReviewQuestions(eventId: $eventId)\n}\n    `;\nexport type PublishAllReviewQuestionsMutationFn = Apollo.MutationFunction<PublishAllReviewQuestionsMutation, PublishAllReviewQuestionsMutationVariables>;\n\n/**\n * __usePublishAllReviewQuestionsMutation__\n *\n * To run a mutation, you first call `usePublishAllReviewQuestionsMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `usePublishAllReviewQuestionsMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [publishAllReviewQuestionsMutation, { data, loading, error }] = usePublishAllReviewQuestionsMutation({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function usePublishAllReviewQuestionsMutation(baseOptions?: Apollo.MutationHookOptions<PublishAllReviewQuestionsMutation, PublishAllReviewQuestionsMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<PublishAllReviewQuestionsMutation, PublishAllReviewQuestionsMutationVariables>(PublishAllReviewQuestionsDocument, options);\n      }\nexport type PublishAllReviewQuestionsMutationHookResult = ReturnType<typeof usePublishAllReviewQuestionsMutation>;\nexport type PublishAllReviewQuestionsMutationResult = Apollo.MutationResult<PublishAllReviewQuestionsMutation>;\nexport type PublishAllReviewQuestionsMutationOptions = Apollo.BaseMutationOptions<PublishAllReviewQuestionsMutation, PublishAllReviewQuestionsMutationVariables>;\nexport const UpdateQuestionReviewStatusDocument = gql`\n    mutation UpdateQuestionReviewStatus($questionId: ID!, $reviewStatus: ReviewStatus!) {\n  updateQuestionReviewStatus(questionId: $questionId, reviewStatus: $reviewStatus) {\n    ...QuestionFields\n  }\n}\n    ${QuestionFieldsFragmentDoc}`;\nexport type UpdateQuestionReviewStatusMutationFn = Apollo.MutationFunction<UpdateQuestionReviewStatusMutation, UpdateQuestionReviewStatusMutationVariables>;\n\n/**\n * __useUpdateQuestionReviewStatusMutation__\n *\n * To run a mutation, you first call `useUpdateQuestionReviewStatusMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateQuestionReviewStatusMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateQuestionReviewStatusMutation, { data, loading, error }] = useUpdateQuestionReviewStatusMutation({\n *   variables: {\n *      questionId: // value for 'questionId'\n *      reviewStatus: // value for 'reviewStatus'\n *   },\n * });\n */\nexport function useUpdateQuestionReviewStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQuestionReviewStatusMutation, UpdateQuestionReviewStatusMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateQuestionReviewStatusMutation, UpdateQuestionReviewStatusMutationVariables>(UpdateQuestionReviewStatusDocument, options);\n      }\nexport type UpdateQuestionReviewStatusMutationHookResult = ReturnType<typeof useUpdateQuestionReviewStatusMutation>;\nexport type UpdateQuestionReviewStatusMutationResult = Apollo.MutationResult<UpdateQuestionReviewStatusMutation>;\nexport type UpdateQuestionReviewStatusMutationOptions = Apollo.BaseMutationOptions<UpdateQuestionReviewStatusMutation, UpdateQuestionReviewStatusMutationVariables>;\nexport const UpdateQuestionStarDocument = gql`\n    mutation UpdateQuestionStar($questionId: ID!, $star: Boolean!) {\n  updateQuestionStar(questionId: $questionId, star: $star) {\n    ...QuestionFields\n  }\n}\n    ${QuestionFieldsFragmentDoc}`;\nexport type UpdateQuestionStarMutationFn = Apollo.MutationFunction<UpdateQuestionStarMutation, UpdateQuestionStarMutationVariables>;\n\n/**\n * __useUpdateQuestionStarMutation__\n *\n * To run a mutation, you first call `useUpdateQuestionStarMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateQuestionStarMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateQuestionStarMutation, { data, loading, error }] = useUpdateQuestionStarMutation({\n *   variables: {\n *      questionId: // value for 'questionId'\n *      star: // value for 'star'\n *   },\n * });\n */\nexport function useUpdateQuestionStarMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQuestionStarMutation, UpdateQuestionStarMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateQuestionStarMutation, UpdateQuestionStarMutationVariables>(UpdateQuestionStarDocument, options);\n      }\nexport type UpdateQuestionStarMutationHookResult = ReturnType<typeof useUpdateQuestionStarMutation>;\nexport type UpdateQuestionStarMutationResult = Apollo.MutationResult<UpdateQuestionStarMutation>;\nexport type UpdateQuestionStarMutationOptions = Apollo.BaseMutationOptions<UpdateQuestionStarMutation, UpdateQuestionStarMutationVariables>;\nexport const UpdateQuestionTopDocument = gql`\n    mutation UpdateQuestionTop($questionId: ID!, $top: Boolean!) {\n  updateQuestionTop(questionId: $questionId, top: $top) {\n    ...QuestionFields\n  }\n}\n    ${QuestionFieldsFragmentDoc}`;\nexport type UpdateQuestionTopMutationFn = Apollo.MutationFunction<UpdateQuestionTopMutation, UpdateQuestionTopMutationVariables>;\n\n/**\n * __useUpdateQuestionTopMutation__\n *\n * To run a mutation, you first call `useUpdateQuestionTopMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateQuestionTopMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateQuestionTopMutation, { data, loading, error }] = useUpdateQuestionTopMutation({\n *   variables: {\n *      questionId: // value for 'questionId'\n *      top: // value for 'top'\n *   },\n * });\n */\nexport function useUpdateQuestionTopMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQuestionTopMutation, UpdateQuestionTopMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateQuestionTopMutation, UpdateQuestionTopMutationVariables>(UpdateQuestionTopDocument, options);\n      }\nexport type UpdateQuestionTopMutationHookResult = ReturnType<typeof useUpdateQuestionTopMutation>;\nexport type UpdateQuestionTopMutationResult = Apollo.MutationResult<UpdateQuestionTopMutation>;\nexport type UpdateQuestionTopMutationOptions = Apollo.BaseMutationOptions<UpdateQuestionTopMutation, UpdateQuestionTopMutationVariables>;\nexport const UpdateQuestionContentDocument = gql`\n    mutation UpdateQuestionContent($questionId: ID!, $content: String!) {\n  updateQuestionContent(questionId: $questionId, content: $content) {\n    ...QuestionFields\n  }\n}\n    ${QuestionFieldsFragmentDoc}`;\nexport type UpdateQuestionContentMutationFn = Apollo.MutationFunction<UpdateQuestionContentMutation, UpdateQuestionContentMutationVariables>;\n\n/**\n * __useUpdateQuestionContentMutation__\n *\n * To run a mutation, you first call `useUpdateQuestionContentMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateQuestionContentMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateQuestionContentMutation, { data, loading, error }] = useUpdateQuestionContentMutation({\n *   variables: {\n *      questionId: // value for 'questionId'\n *      content: // value for 'content'\n *   },\n * });\n */\nexport function useUpdateQuestionContentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateQuestionContentMutation, UpdateQuestionContentMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateQuestionContentMutation, UpdateQuestionContentMutationVariables>(UpdateQuestionContentDocument, options);\n      }\nexport type UpdateQuestionContentMutationHookResult = ReturnType<typeof useUpdateQuestionContentMutation>;\nexport type UpdateQuestionContentMutationResult = Apollo.MutationResult<UpdateQuestionContentMutation>;\nexport type UpdateQuestionContentMutationOptions = Apollo.BaseMutationOptions<UpdateQuestionContentMutation, UpdateQuestionContentMutationVariables>;\nexport const CreateReplyDocument = gql`\n    mutation CreateReply($input: CreateReplyInput!) {\n  createReply(input: $input) {\n    ...ReplyFields\n  }\n}\n    ${ReplyFieldsFragmentDoc}`;\nexport type CreateReplyMutationFn = Apollo.MutationFunction<CreateReplyMutation, CreateReplyMutationVariables>;\n\n/**\n * __useCreateReplyMutation__\n *\n * To run a mutation, you first call `useCreateReplyMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateReplyMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createReplyMutation, { data, loading, error }] = useCreateReplyMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useCreateReplyMutation(baseOptions?: Apollo.MutationHookOptions<CreateReplyMutation, CreateReplyMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<CreateReplyMutation, CreateReplyMutationVariables>(CreateReplyDocument, options);\n      }\nexport type CreateReplyMutationHookResult = ReturnType<typeof useCreateReplyMutation>;\nexport type CreateReplyMutationResult = Apollo.MutationResult<CreateReplyMutation>;\nexport type CreateReplyMutationOptions = Apollo.BaseMutationOptions<CreateReplyMutation, CreateReplyMutationVariables>;\nexport const UpdateReplyContentDocument = gql`\n    mutation UpdateReplyContent($replyId: ID!, $content: String!) {\n  updateReplyContent(replyId: $replyId, content: $content) {\n    ...ReplyFields\n  }\n}\n    ${ReplyFieldsFragmentDoc}`;\nexport type UpdateReplyContentMutationFn = Apollo.MutationFunction<UpdateReplyContentMutation, UpdateReplyContentMutationVariables>;\n\n/**\n * __useUpdateReplyContentMutation__\n *\n * To run a mutation, you first call `useUpdateReplyContentMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateReplyContentMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateReplyContentMutation, { data, loading, error }] = useUpdateReplyContentMutation({\n *   variables: {\n *      replyId: // value for 'replyId'\n *      content: // value for 'content'\n *   },\n * });\n */\nexport function useUpdateReplyContentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReplyContentMutation, UpdateReplyContentMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateReplyContentMutation, UpdateReplyContentMutationVariables>(UpdateReplyContentDocument, options);\n      }\nexport type UpdateReplyContentMutationHookResult = ReturnType<typeof useUpdateReplyContentMutation>;\nexport type UpdateReplyContentMutationResult = Apollo.MutationResult<UpdateReplyContentMutation>;\nexport type UpdateReplyContentMutationOptions = Apollo.BaseMutationOptions<UpdateReplyContentMutation, UpdateReplyContentMutationVariables>;\nexport const UpdateReplyReviewStatusDocument = gql`\n    mutation UpdateReplyReviewStatus($replyId: ID!, $reviewStatus: ReviewStatus!) {\n  updateReplyReviewStatus(replyId: $replyId, reviewStatus: $reviewStatus) {\n    ...ReplyFields\n  }\n}\n    ${ReplyFieldsFragmentDoc}`;\nexport type UpdateReplyReviewStatusMutationFn = Apollo.MutationFunction<UpdateReplyReviewStatusMutation, UpdateReplyReviewStatusMutationVariables>;\n\n/**\n * __useUpdateReplyReviewStatusMutation__\n *\n * To run a mutation, you first call `useUpdateReplyReviewStatusMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateReplyReviewStatusMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateReplyReviewStatusMutation, { data, loading, error }] = useUpdateReplyReviewStatusMutation({\n *   variables: {\n *      replyId: // value for 'replyId'\n *      reviewStatus: // value for 'reviewStatus'\n *   },\n * });\n */\nexport function useUpdateReplyReviewStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReplyReviewStatusMutation, UpdateReplyReviewStatusMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateReplyReviewStatusMutation, UpdateReplyReviewStatusMutationVariables>(UpdateReplyReviewStatusDocument, options);\n      }\nexport type UpdateReplyReviewStatusMutationHookResult = ReturnType<typeof useUpdateReplyReviewStatusMutation>;\nexport type UpdateReplyReviewStatusMutationResult = Apollo.MutationResult<UpdateReplyReviewStatusMutation>;\nexport type UpdateReplyReviewStatusMutationOptions = Apollo.BaseMutationOptions<UpdateReplyReviewStatusMutation, UpdateReplyReviewStatusMutationVariables>;\nexport const DeleteReplyDocument = gql`\n    mutation DeleteReply($replyId: ID!) {\n  deleteReply(replyId: $replyId) {\n    id\n  }\n}\n    `;\nexport type DeleteReplyMutationFn = Apollo.MutationFunction<DeleteReplyMutation, DeleteReplyMutationVariables>;\n\n/**\n * __useDeleteReplyMutation__\n *\n * To run a mutation, you first call `useDeleteReplyMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteReplyMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteReplyMutation, { data, loading, error }] = useDeleteReplyMutation({\n *   variables: {\n *      replyId: // value for 'replyId'\n *   },\n * });\n */\nexport function useDeleteReplyMutation(baseOptions?: Apollo.MutationHookOptions<DeleteReplyMutation, DeleteReplyMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<DeleteReplyMutation, DeleteReplyMutationVariables>(DeleteReplyDocument, options);\n      }\nexport type DeleteReplyMutationHookResult = ReturnType<typeof useDeleteReplyMutation>;\nexport type DeleteReplyMutationResult = Apollo.MutationResult<DeleteReplyMutation>;\nexport type DeleteReplyMutationOptions = Apollo.BaseMutationOptions<DeleteReplyMutation, DeleteReplyMutationVariables>;\nexport const EventsByMeDocument = gql`\n    query EventsByMe($searchString: String, $pagination: PaginationInput!, $eventOwnerFilter: EventOwnerFilter, $dateStatusFilter: EventDateStatus) {\n  eventsByMe(\n    searchString: $searchString\n    pagination: $pagination\n    eventOwnerFilter: $eventOwnerFilter\n    dateStatusFilter: $dateStatusFilter\n  ) {\n    limit\n    offset\n    totalCount\n    hasNextPage\n    list {\n      ...EventFields\n    }\n  }\n}\n    ${EventFieldsFragmentDoc}`;\n\n/**\n * __useEventsByMeQuery__\n *\n * To run a query within a React component, call `useEventsByMeQuery` and pass it any options that fit your needs.\n * When your component renders, `useEventsByMeQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useEventsByMeQuery({\n *   variables: {\n *      searchString: // value for 'searchString'\n *      pagination: // value for 'pagination'\n *      eventOwnerFilter: // value for 'eventOwnerFilter'\n *      dateStatusFilter: // value for 'dateStatusFilter'\n *   },\n * });\n */\nexport function useEventsByMeQuery(baseOptions: Apollo.QueryHookOptions<EventsByMeQuery, EventsByMeQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<EventsByMeQuery, EventsByMeQueryVariables>(EventsByMeDocument, options);\n      }\nexport function useEventsByMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsByMeQuery, EventsByMeQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<EventsByMeQuery, EventsByMeQueryVariables>(EventsByMeDocument, options);\n        }\nexport type EventsByMeQueryHookResult = ReturnType<typeof useEventsByMeQuery>;\nexport type EventsByMeLazyQueryHookResult = ReturnType<typeof useEventsByMeLazyQuery>;\nexport type EventsByMeQueryResult = Apollo.QueryResult<EventsByMeQuery, EventsByMeQueryVariables>;\nexport const EventByIdDocument = gql`\n    query EventById($eventId: ID!) {\n  eventById(eventId: $eventId) {\n    ...EventDetailFields\n  }\n}\n    ${EventDetailFieldsFragmentDoc}`;\n\n/**\n * __useEventByIdQuery__\n *\n * To run a query within a React component, call `useEventByIdQuery` and pass it any options that fit your needs.\n * When your component renders, `useEventByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useEventByIdQuery({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useEventByIdQuery(baseOptions: Apollo.QueryHookOptions<EventByIdQuery, EventByIdQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<EventByIdQuery, EventByIdQueryVariables>(EventByIdDocument, options);\n      }\nexport function useEventByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventByIdQuery, EventByIdQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<EventByIdQuery, EventByIdQueryVariables>(EventByIdDocument, options);\n        }\nexport type EventByIdQueryHookResult = ReturnType<typeof useEventByIdQuery>;\nexport type EventByIdLazyQueryHookResult = ReturnType<typeof useEventByIdLazyQuery>;\nexport type EventByIdQueryResult = Apollo.QueryResult<EventByIdQuery, EventByIdQueryVariables>;\nexport const CheckEventCodeExistDocument = gql`\n    query CheckEventCodeExist($code: String!) {\n  checkEventCodeExist(code: $code)\n}\n    `;\n\n/**\n * __useCheckEventCodeExistQuery__\n *\n * To run a query within a React component, call `useCheckEventCodeExistQuery` and pass it any options that fit your needs.\n * When your component renders, `useCheckEventCodeExistQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useCheckEventCodeExistQuery({\n *   variables: {\n *      code: // value for 'code'\n *   },\n * });\n */\nexport function useCheckEventCodeExistQuery(baseOptions: Apollo.QueryHookOptions<CheckEventCodeExistQuery, CheckEventCodeExistQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<CheckEventCodeExistQuery, CheckEventCodeExistQueryVariables>(CheckEventCodeExistDocument, options);\n      }\nexport function useCheckEventCodeExistLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CheckEventCodeExistQuery, CheckEventCodeExistQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<CheckEventCodeExistQuery, CheckEventCodeExistQueryVariables>(CheckEventCodeExistDocument, options);\n        }\nexport type CheckEventCodeExistQueryHookResult = ReturnType<typeof useCheckEventCodeExistQuery>;\nexport type CheckEventCodeExistLazyQueryHookResult = ReturnType<typeof useCheckEventCodeExistLazyQuery>;\nexport type CheckEventCodeExistQueryResult = Apollo.QueryResult<CheckEventCodeExistQuery, CheckEventCodeExistQueryVariables>;\nexport const CreateEventDocument = gql`\n    mutation CreateEvent($code: String!, $name: String!, $startAt: DateTime!, $endAt: DateTime!) {\n  createEvent(code: $code, name: $name, startAt: $startAt, endAt: $endAt) {\n    ...EventFields\n  }\n}\n    ${EventFieldsFragmentDoc}`;\nexport type CreateEventMutationFn = Apollo.MutationFunction<CreateEventMutation, CreateEventMutationVariables>;\n\n/**\n * __useCreateEventMutation__\n *\n * To run a mutation, you first call `useCreateEventMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateEventMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createEventMutation, { data, loading, error }] = useCreateEventMutation({\n *   variables: {\n *      code: // value for 'code'\n *      name: // value for 'name'\n *      startAt: // value for 'startAt'\n *      endAt: // value for 'endAt'\n *   },\n * });\n */\nexport function useCreateEventMutation(baseOptions?: Apollo.MutationHookOptions<CreateEventMutation, CreateEventMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, options);\n      }\nexport type CreateEventMutationHookResult = ReturnType<typeof useCreateEventMutation>;\nexport type CreateEventMutationResult = Apollo.MutationResult<CreateEventMutation>;\nexport type CreateEventMutationOptions = Apollo.BaseMutationOptions<CreateEventMutation, CreateEventMutationVariables>;\nexport const UpdateEventDocument = gql`\n    mutation UpdateEvent($input: UpdateEventInput!) {\n  updateEvent(input: $input) {\n    ...EventDetailFields\n  }\n}\n    ${EventDetailFieldsFragmentDoc}`;\nexport type UpdateEventMutationFn = Apollo.MutationFunction<UpdateEventMutation, UpdateEventMutationVariables>;\n\n/**\n * __useUpdateEventMutation__\n *\n * To run a mutation, you first call `useUpdateEventMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateEventMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateEventMutation, { data, loading, error }] = useUpdateEventMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useUpdateEventMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventMutation, UpdateEventMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateEventMutation, UpdateEventMutationVariables>(UpdateEventDocument, options);\n      }\nexport type UpdateEventMutationHookResult = ReturnType<typeof useUpdateEventMutation>;\nexport type UpdateEventMutationResult = Apollo.MutationResult<UpdateEventMutation>;\nexport type UpdateEventMutationOptions = Apollo.BaseMutationOptions<UpdateEventMutation, UpdateEventMutationVariables>;\nexport const DeleteEventDocument = gql`\n    mutation DeleteEvent($eventId: ID!) {\n  deleteEvent(eventId: $eventId) {\n    id\n  }\n}\n    `;\nexport type DeleteEventMutationFn = Apollo.MutationFunction<DeleteEventMutation, DeleteEventMutationVariables>;\n\n/**\n * __useDeleteEventMutation__\n *\n * To run a mutation, you first call `useDeleteEventMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteEventMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteEventMutation, { data, loading, error }] = useDeleteEventMutation({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useDeleteEventMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventMutation, DeleteEventMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<DeleteEventMutation, DeleteEventMutationVariables>(DeleteEventDocument, options);\n      }\nexport type DeleteEventMutationHookResult = ReturnType<typeof useDeleteEventMutation>;\nexport type DeleteEventMutationResult = Apollo.MutationResult<DeleteEventMutation>;\nexport type DeleteEventMutationOptions = Apollo.BaseMutationOptions<DeleteEventMutation, DeleteEventMutationVariables>;\nexport const PgpDocument = gql`\n    query PGP {\n  pgp {\n    pubKey\n  }\n}\n    `;\n\n/**\n * __usePgpQuery__\n *\n * To run a query within a React component, call `usePgpQuery` and pass it any options that fit your needs.\n * When your component renders, `usePgpQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = usePgpQuery({\n *   variables: {\n *   },\n * });\n */\nexport function usePgpQuery(baseOptions?: Apollo.QueryHookOptions<PgpQuery, PgpQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<PgpQuery, PgpQueryVariables>(PgpDocument, options);\n      }\nexport function usePgpLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PgpQuery, PgpQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<PgpQuery, PgpQueryVariables>(PgpDocument, options);\n        }\nexport type PgpQueryHookResult = ReturnType<typeof usePgpQuery>;\nexport type PgpLazyQueryHookResult = ReturnType<typeof usePgpLazyQuery>;\nexport type PgpQueryResult = Apollo.QueryResult<PgpQuery, PgpQueryVariables>;\nexport const PackageInfoDocument = gql`\n    mutation PackageInfo($version: String, $description: String) {\n  packageInfo(version: $version, description: $description) @client {\n    version\n    description\n  }\n}\n    `;\nexport type PackageInfoMutationFn = Apollo.MutationFunction<PackageInfoMutation, PackageInfoMutationVariables>;\n\n/**\n * __usePackageInfoMutation__\n *\n * To run a mutation, you first call `usePackageInfoMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `usePackageInfoMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [packageInfoMutation, { data, loading, error }] = usePackageInfoMutation({\n *   variables: {\n *      version: // value for 'version'\n *      description: // value for 'description'\n *   },\n * });\n */\nexport function usePackageInfoMutation(baseOptions?: Apollo.MutationHookOptions<PackageInfoMutation, PackageInfoMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<PackageInfoMutation, PackageInfoMutationVariables>(PackageInfoDocument, options);\n      }\nexport type PackageInfoMutationHookResult = ReturnType<typeof usePackageInfoMutation>;\nexport type PackageInfoMutationResult = Apollo.MutationResult<PackageInfoMutation>;\nexport type PackageInfoMutationOptions = Apollo.BaseMutationOptions<PackageInfoMutation, PackageInfoMutationVariables>;\nexport const EventForLoginDocument = gql`\n    query EventForLogin($eventId: ID!) {\n  eventById(eventId: $eventId) {\n    id\n    name\n    code\n    startAt\n    endAt\n  }\n}\n    `;\n\n/**\n * __useEventForLoginQuery__\n *\n * To run a query within a React component, call `useEventForLoginQuery` and pass it any options that fit your needs.\n * When your component renders, `useEventForLoginQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useEventForLoginQuery({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useEventForLoginQuery(baseOptions: Apollo.QueryHookOptions<EventForLoginQuery, EventForLoginQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<EventForLoginQuery, EventForLoginQueryVariables>(EventForLoginDocument, options);\n      }\nexport function useEventForLoginLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventForLoginQuery, EventForLoginQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<EventForLoginQuery, EventForLoginQueryVariables>(EventForLoginDocument, options);\n        }\nexport type EventForLoginQueryHookResult = ReturnType<typeof useEventForLoginQuery>;\nexport type EventForLoginLazyQueryHookResult = ReturnType<typeof useEventForLoginLazyQuery>;\nexport type EventForLoginQueryResult = Apollo.QueryResult<EventForLoginQuery, EventForLoginQueryVariables>;\nexport const CreateQuestionDocument = gql`\n    mutation CreateQuestion($input: CreateQuestionInput!) {\n  createQuestion(input: $input) {\n    ...QuestionAudienceFields\n  }\n}\n    ${QuestionAudienceFieldsFragmentDoc}`;\nexport type CreateQuestionMutationFn = Apollo.MutationFunction<CreateQuestionMutation, CreateQuestionMutationVariables>;\n\n/**\n * __useCreateQuestionMutation__\n *\n * To run a mutation, you first call `useCreateQuestionMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateQuestionMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createQuestionMutation, { data, loading, error }] = useCreateQuestionMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useCreateQuestionMutation(baseOptions?: Apollo.MutationHookOptions<CreateQuestionMutation, CreateQuestionMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<CreateQuestionMutation, CreateQuestionMutationVariables>(CreateQuestionDocument, options);\n      }\nexport type CreateQuestionMutationHookResult = ReturnType<typeof useCreateQuestionMutation>;\nexport type CreateQuestionMutationResult = Apollo.MutationResult<CreateQuestionMutation>;\nexport type CreateQuestionMutationOptions = Apollo.BaseMutationOptions<CreateQuestionMutation, CreateQuestionMutationVariables>;\nexport const VoteUpQuestionDocument = gql`\n    mutation VoteUpQuestion($questionId: ID!) {\n  voteUpQuestion(questionId: $questionId) {\n    ...QuestionAudienceFields\n  }\n}\n    ${QuestionAudienceFieldsFragmentDoc}`;\nexport type VoteUpQuestionMutationFn = Apollo.MutationFunction<VoteUpQuestionMutation, VoteUpQuestionMutationVariables>;\n\n/**\n * __useVoteUpQuestionMutation__\n *\n * To run a mutation, you first call `useVoteUpQuestionMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useVoteUpQuestionMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [voteUpQuestionMutation, { data, loading, error }] = useVoteUpQuestionMutation({\n *   variables: {\n *      questionId: // value for 'questionId'\n *   },\n * });\n */\nexport function useVoteUpQuestionMutation(baseOptions?: Apollo.MutationHookOptions<VoteUpQuestionMutation, VoteUpQuestionMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<VoteUpQuestionMutation, VoteUpQuestionMutationVariables>(VoteUpQuestionDocument, options);\n      }\nexport type VoteUpQuestionMutationHookResult = ReturnType<typeof useVoteUpQuestionMutation>;\nexport type VoteUpQuestionMutationResult = Apollo.MutationResult<VoteUpQuestionMutation>;\nexport type VoteUpQuestionMutationOptions = Apollo.BaseMutationOptions<VoteUpQuestionMutation, VoteUpQuestionMutationVariables>;\nexport const LoginAudienceDocument = gql`\n    mutation LoginAudience($fingerprint: String!) {\n  loginAudience(fingerprint: $fingerprint) {\n    token\n    user {\n      name\n    }\n  }\n}\n    `;\nexport type LoginAudienceMutationFn = Apollo.MutationFunction<LoginAudienceMutation, LoginAudienceMutationVariables>;\n\n/**\n * __useLoginAudienceMutation__\n *\n * To run a mutation, you first call `useLoginAudienceMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLoginAudienceMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [loginAudienceMutation, { data, loading, error }] = useLoginAudienceMutation({\n *   variables: {\n *      fingerprint: // value for 'fingerprint'\n *   },\n * });\n */\nexport function useLoginAudienceMutation(baseOptions?: Apollo.MutationHookOptions<LoginAudienceMutation, LoginAudienceMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<LoginAudienceMutation, LoginAudienceMutationVariables>(LoginAudienceDocument, options);\n      }\nexport type LoginAudienceMutationHookResult = ReturnType<typeof useLoginAudienceMutation>;\nexport type LoginAudienceMutationResult = Apollo.MutationResult<LoginAudienceMutation>;\nexport type LoginAudienceMutationOptions = Apollo.BaseMutationOptions<LoginAudienceMutation, LoginAudienceMutationVariables>;\nexport const IsEventAudienceDocument = gql`\n    query IsEventAudience($eventId: ID!) {\n  isEventAudience(eventId: $eventId)\n}\n    `;\n\n/**\n * __useIsEventAudienceQuery__\n *\n * To run a query within a React component, call `useIsEventAudienceQuery` and pass it any options that fit your needs.\n * When your component renders, `useIsEventAudienceQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useIsEventAudienceQuery({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useIsEventAudienceQuery(baseOptions: Apollo.QueryHookOptions<IsEventAudienceQuery, IsEventAudienceQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<IsEventAudienceQuery, IsEventAudienceQueryVariables>(IsEventAudienceDocument, options);\n      }\nexport function useIsEventAudienceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IsEventAudienceQuery, IsEventAudienceQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<IsEventAudienceQuery, IsEventAudienceQueryVariables>(IsEventAudienceDocument, options);\n        }\nexport type IsEventAudienceQueryHookResult = ReturnType<typeof useIsEventAudienceQuery>;\nexport type IsEventAudienceLazyQueryHookResult = ReturnType<typeof useIsEventAudienceLazyQuery>;\nexport type IsEventAudienceQueryResult = Apollo.QueryResult<IsEventAudienceQuery, IsEventAudienceQueryVariables>;\nexport const JoinEventDocument = gql`\n    mutation JoinEvent($eventId: ID!) {\n  joinEvent(eventId: $eventId)\n}\n    `;\nexport type JoinEventMutationFn = Apollo.MutationFunction<JoinEventMutation, JoinEventMutationVariables>;\n\n/**\n * __useJoinEventMutation__\n *\n * To run a mutation, you first call `useJoinEventMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useJoinEventMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [joinEventMutation, { data, loading, error }] = useJoinEventMutation({\n *   variables: {\n *      eventId: // value for 'eventId'\n *   },\n * });\n */\nexport function useJoinEventMutation(baseOptions?: Apollo.MutationHookOptions<JoinEventMutation, JoinEventMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<JoinEventMutation, JoinEventMutationVariables>(JoinEventDocument, options);\n      }\nexport type JoinEventMutationHookResult = ReturnType<typeof useJoinEventMutation>;\nexport type JoinEventMutationResult = Apollo.MutationResult<JoinEventMutation>;\nexport type JoinEventMutationOptions = Apollo.BaseMutationOptions<JoinEventMutation, JoinEventMutationVariables>;\nexport const EventCodeOptionsDocument = gql`\n    query EventCodeOptions($code: String) {\n  eventsByCode(code: $code) {\n    id\n    code\n    name\n    startAt\n    endAt\n  }\n}\n    `;\n\n/**\n * __useEventCodeOptionsQuery__\n *\n * To run a query within a React component, call `useEventCodeOptionsQuery` and pass it any options that fit your needs.\n * When your component renders, `useEventCodeOptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useEventCodeOptionsQuery({\n *   variables: {\n *      code: // value for 'code'\n *   },\n * });\n */\nexport function useEventCodeOptionsQuery(baseOptions?: Apollo.QueryHookOptions<EventCodeOptionsQuery, EventCodeOptionsQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<EventCodeOptionsQuery, EventCodeOptionsQueryVariables>(EventCodeOptionsDocument, options);\n      }\nexport function useEventCodeOptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventCodeOptionsQuery, EventCodeOptionsQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<EventCodeOptionsQuery, EventCodeOptionsQueryVariables>(EventCodeOptionsDocument, options);\n        }\nexport type EventCodeOptionsQueryHookResult = ReturnType<typeof useEventCodeOptionsQuery>;\nexport type EventCodeOptionsLazyQueryHookResult = ReturnType<typeof useEventCodeOptionsLazyQuery>;\nexport type EventCodeOptionsQueryResult = Apollo.QueryResult<EventCodeOptionsQuery, EventCodeOptionsQueryVariables>;\nexport const MeDocument = gql`\n    query Me {\n  me {\n    ...UserInfo\n  }\n}\n    ${UserInfoFragmentDoc}`;\n\n/**\n * __useMeQuery__\n *\n * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.\n * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useMeQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);\n      }\nexport function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);\n        }\nexport type MeQueryHookResult = ReturnType<typeof useMeQuery>;\nexport type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;\nexport type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;\nexport const UpdateUserDocument = gql`\n    mutation UpdateUser($input: UpdateUserInput!) {\n  updateUser(input: $input) {\n    ...UserInfo\n  }\n}\n    ${UserInfoFragmentDoc}`;\nexport type UpdateUserMutationFn = Apollo.MutationFunction<UpdateUserMutation, UpdateUserMutationVariables>;\n\n/**\n * __useUpdateUserMutation__\n *\n * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateUserMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useUpdateUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserMutation, UpdateUserMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument, options);\n      }\nexport type UpdateUserMutationHookResult = ReturnType<typeof useUpdateUserMutation>;\nexport type UpdateUserMutationResult = Apollo.MutationResult<UpdateUserMutation>;\nexport type UpdateUserMutationOptions = Apollo.BaseMutationOptions<UpdateUserMutation, UpdateUserMutationVariables>;\nexport const LoginDocument = gql`\n    mutation Login($email: String!, $password: String!) {\n  login(password: $password, email: $email) {\n    token\n    user {\n      name\n      email\n    }\n  }\n}\n    `;\nexport type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;\n\n/**\n * __useLoginMutation__\n *\n * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLoginMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [loginMutation, { data, loading, error }] = useLoginMutation({\n *   variables: {\n *      email: // value for 'email'\n *      password: // value for 'password'\n *   },\n * });\n */\nexport function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, options);\n      }\nexport type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;\nexport type LoginMutationResult = Apollo.MutationResult<LoginMutation>;\nexport type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;\nexport const SignupDocument = gql`\n    mutation Signup($name: String!, $email: String!, $password: String!) {\n  signup(name: $name, password: $password, email: $email) {\n    token\n    user {\n      name\n      email\n    }\n  }\n}\n    `;\nexport type SignupMutationFn = Apollo.MutationFunction<SignupMutation, SignupMutationVariables>;\n\n/**\n * __useSignupMutation__\n *\n * To run a mutation, you first call `useSignupMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useSignupMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [signupMutation, { data, loading, error }] = useSignupMutation({\n *   variables: {\n *      name: // value for 'name'\n *      email: // value for 'email'\n *      password: // value for 'password'\n *   },\n * });\n */\nexport function useSignupMutation(baseOptions?: Apollo.MutationHookOptions<SignupMutation, SignupMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<SignupMutation, SignupMutationVariables>(SignupDocument, options);\n      }\nexport type SignupMutationHookResult = ReturnType<typeof useSignupMutation>;\nexport type SignupMutationResult = Apollo.MutationResult<SignupMutation>;\nexport type SignupMutationOptions = Apollo.BaseMutationOptions<SignupMutation, SignupMutationVariables>;\nexport const CheckEmailExistDocument = gql`\n    query CheckEmailExist($email: String!) {\n  checkEmailExist(email: $email)\n}\n    `;\n\n/**\n * __useCheckEmailExistQuery__\n *\n * To run a query within a React component, call `useCheckEmailExistQuery` and pass it any options that fit your needs.\n * When your component renders, `useCheckEmailExistQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useCheckEmailExistQuery({\n *   variables: {\n *      email: // value for 'email'\n *   },\n * });\n */\nexport function useCheckEmailExistQuery(baseOptions: Apollo.QueryHookOptions<CheckEmailExistQuery, CheckEmailExistQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<CheckEmailExistQuery, CheckEmailExistQueryVariables>(CheckEmailExistDocument, options);\n      }\nexport function useCheckEmailExistLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CheckEmailExistQuery, CheckEmailExistQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<CheckEmailExistQuery, CheckEmailExistQueryVariables>(CheckEmailExistDocument, options);\n        }\nexport type CheckEmailExistQueryHookResult = ReturnType<typeof useCheckEmailExistQuery>;\nexport type CheckEmailExistLazyQueryHookResult = ReturnType<typeof useCheckEmailExistLazyQuery>;\nexport type CheckEmailExistQueryResult = Apollo.QueryResult<CheckEmailExistQuery, CheckEmailExistQueryVariables>;"],"sourceRoot":""}